{"version":3,"file":"react-hotkeys-hook.esm.js","sources":["../src/useIsHotkeyPressed.ts","../src/useHotkeys.ts","../src/index.ts"],"sourcesContent":["import hotkeys from 'hotkeys-js';\n\n/**\n * @deprecated Use isHotkeyPressed instead. Will be removed version 4.\n */\nexport function useIsHotkeyPressed() {\n  return hotkeys.isPressed;\n}","import hotkeys, { HotkeysEvent, KeyHandler } from 'hotkeys-js';\nimport React, { useCallback, useEffect, useRef } from 'react';\n\ntype AvailableTags = 'INPUT' | 'TEXTAREA' | 'SELECT';\n\n// We implement our own custom filter system.\nhotkeys.filter = () => true;\n\nconst tagFilter = ({ target }: KeyboardEvent, enableOnTags?: AvailableTags[]) => {\n  const targetTagName = target && (target as HTMLElement).tagName;\n\n  return Boolean((targetTagName && enableOnTags && enableOnTags.includes(targetTagName as AvailableTags)));\n};\n\nconst isKeyboardEventTriggeredByInput = (ev: KeyboardEvent) => {\n  return tagFilter(ev, ['INPUT', 'TEXTAREA', 'SELECT']);\n};\n\nexport type Options = {\n  enabled?: boolean; // Main setting that determines if the hotkey is enabled or not. (Default: true)\n  filter?: typeof hotkeys.filter; // A filter function returning whether the callback should get triggered or not. (Default: undefined)\n  filterPreventDefault?: boolean; // Prevent default browser behavior if the filter function returns false. (Default: true)\n  enableOnTags?: AvailableTags[]; // Enable hotkeys on a list of tags. (Default: [])\n  enableOnContentEditable?: boolean; // Enable hotkeys on tags with contentEditable props. (Default: false)\n  splitKey?: string; // Character to split keys in hotkeys combinations. (Default +)\n  scope?: string; // Scope. Currently not doing anything.\n  keyup?: boolean; // Trigger on keyup event? (Default: undefined)\n  keydown?: boolean; // Trigger on keydown event? (Default: true)\n  capture?: boolean; // A boolean value indicating that events of this type will be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the DOM tree. If not specified, defaults to false.\n};\n\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: any[] | Options, deps?: any[]): React.MutableRefObject<T | null> {\n  if (options instanceof Array) {\n    deps = options;\n    options = undefined;\n  }\n\n  const {\n    enableOnTags,\n    filter,\n    keyup,\n    keydown,\n    filterPreventDefault = true,\n    enabled = true,\n    enableOnContentEditable = false,\n    capture = false,\n  } = options as Options || {};\n  const ref = useRef<T | null>(null);\n\n  // The return value of this callback determines if the browsers default behavior is prevented.\n  const memoisedCallback = useCallback((keyboardEvent: KeyboardEvent, hotkeysEvent: HotkeysEvent) => {\n    if (filter && !filter(keyboardEvent)) {\n      return !filterPreventDefault;\n    }\n\n    // Check whether the hotkeys was triggered inside an input and that input is enabled or if it was triggered by a content editable tag and it is enabled.\n    if (\n      (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags))\n      || ((keyboardEvent.target as HTMLElement)?.isContentEditable && !enableOnContentEditable)\n    ) {\n      return true;\n    }\n\n    if (ref.current === null || document.activeElement === ref.current) {\n      callback(keyboardEvent, hotkeysEvent);\n      return true;\n    }\n\n    return false;\n  }, deps ? [ref, enableOnTags, filter, ...deps] : [ref, enableOnTags, filter]);\n\n  useEffect(() => {\n    if (!enabled) {\n      hotkeys.unbind(keys, memoisedCallback);\n\n      return;\n    }\n\n    // In this case keydown is likely undefined, so we set it to false, since hotkeys needs the `keydown` key to have a value.\n    if (keyup && keydown !== true) {\n      (options as Options).keydown = false;\n    }\n\n    hotkeys(keys, (options as Options) || {}, memoisedCallback);\n\n    return () => hotkeys.unbind(keys, memoisedCallback);\n  }, [memoisedCallback, keys, enabled]);\n\n  return ref;\n}\n","import { useIsHotkeyPressed } from './useIsHotkeyPressed';\nimport { useHotkeys, Options } from './useHotkeys';\nimport hotkeys from 'hotkeys-js';\n\nconst isHotkeyPressed = hotkeys.isPressed;\n\nexport { useHotkeys, useIsHotkeyPressed, isHotkeyPressed, Options };"],"names":["useIsHotkeyPressed","hotkeys","isPressed","filter","tagFilter","enableOnTags","target","targetTagName","tagName","Boolean","includes","isKeyboardEventTriggeredByInput","ev","useHotkeys","keys","callback","options","deps","Array","undefined","keyup","keydown","filterPreventDefault","enabled","enableOnContentEditable","ref","useRef","memoisedCallback","useCallback","keyboardEvent","hotkeysEvent","isContentEditable","current","document","activeElement","useEffect","unbind","isHotkeyPressed"],"mappings":";;;AAEA;;;;SAGgBA;EACd,OAAOC,OAAO,CAACC,SAAf;AACD;;ACDDD,OAAO,CAACE,MAAR,GAAiB;EAAA,OAAM,IAAN;AAAA,CAAjB;;AAEA,IAAMC,SAAS,GAAG,SAAZA,SAAY,OAA4BC,YAA5B;MAAGC,cAAAA;EACnB,IAAMC,aAAa,GAAGD,MAAM,IAAKA,MAAsB,CAACE,OAAxD;EAEA,OAAOC,OAAO,CAAEF,aAAa,IAAIF,YAAjB,IAAiCA,YAAY,CAACK,QAAb,CAAsBH,aAAtB,CAAnC,CAAd;AACD,CAJD;;AAMA,IAAMI,+BAA+B,GAAG,SAAlCA,+BAAkC,CAACC,EAAD;EACtC,OAAOR,SAAS,CAACQ,EAAD,EAAK,CAAC,OAAD,EAAU,UAAV,EAAsB,QAAtB,CAAL,CAAhB;AACD,CAFD;;AAoBA,SAAgBC,WAA8BC,MAAcC,UAAsBC,SAA2BC;EAC3G,IAAID,OAAO,YAAYE,KAAvB,EAA8B;IAC5BD,IAAI,GAAGD,OAAP;IACAA,OAAO,GAAGG,SAAV;;;EAGF,YASIH,OAAkB,IAAI,EAT1B;MACEX,YADF,SACEA,YADF;MAEEF,MAFF,SAEEA,MAFF;MAGEiB,KAHF,SAGEA,KAHF;MAIEC,OAJF,SAIEA,OAJF;oCAKEC,oBALF;MAKEA,oBALF,sCAKyB,IALzB;4BAMEC,OANF;MAMEA,OANF,8BAMY,IANZ;oCAOEC,uBAPF;MAOEA,uBAPF,sCAO4B,KAP5B;;EAUA,IAAMC,GAAG,GAAGC,MAAM,CAAW,IAAX,CAAlB;;EAGA,IAAMC,gBAAgB,GAAGC,WAAW,CAAC,UAACC,aAAD,EAA+BC,YAA/B;;;IACnC,IAAI3B,MAAM,IAAI,CAACA,MAAM,CAAC0B,aAAD,CAArB,EAAsC;MACpC,OAAO,CAACP,oBAAR;;;;IAIF,IACGX,+BAA+B,CAACkB,aAAD,CAA/B,IAAkD,CAACzB,SAAS,CAACyB,aAAD,EAAgBxB,YAAhB,CAA7D,IACK,yBAAAwB,aAAa,CAACvB,MAAd,mCAAsCyB,iBAAtC,IAA2D,CAACP,uBAFnE,EAGE;MACA,OAAO,IAAP;;;IAGF,IAAIC,GAAG,CAACO,OAAJ,KAAgB,IAAhB,IAAwBC,QAAQ,CAACC,aAAT,KAA2BT,GAAG,CAACO,OAA3D,EAAoE;MAClEjB,QAAQ,CAACc,aAAD,EAAgBC,YAAhB,CAAR;MACA,OAAO,IAAP;;;IAGF,OAAO,KAAP;GAlBkC,EAmBjCb,IAAI,IAAIQ,GAAJ,EAASpB,YAAT,EAAuBF,MAAvB,SAAkCc,IAAlC,IAA0C,CAACQ,GAAD,EAAMpB,YAAN,EAAoBF,MAApB,CAnBb,CAApC;EAqBAgC,SAAS,CAAC;IACR,IAAI,CAACZ,OAAL,EAAc;MACZtB,OAAO,CAACmC,MAAR,CAAetB,IAAf,EAAqBa,gBAArB;MAEA;;;;IAIF,IAAIP,KAAK,IAAIC,OAAO,KAAK,IAAzB,EAA+B;MAC5BL,OAAmB,CAACK,OAApB,GAA8B,KAA9B;;;IAGHpB,OAAO,CAACa,IAAD,EAAQE,OAAmB,IAAI,EAA/B,EAAmCW,gBAAnC,CAAP;IAEA,OAAO;MAAA,OAAM1B,OAAO,CAACmC,MAAR,CAAetB,IAAf,EAAqBa,gBAArB,CAAN;KAAP;GAdO,EAeN,CAACA,gBAAD,EAAmBb,IAAnB,EAAyBS,OAAzB,CAfM,CAAT;EAiBA,OAAOE,GAAP;AACD;;ICxFKY,eAAe,GAAGpC,OAAO,CAACC,SAAhC;;;;"}